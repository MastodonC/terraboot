# Configuration

## What does terraboot do

It generates [terraform]()-readable json. Make sure you have latest terraform installed, they do tend to fix bugs from one version to the other

## Modules

terraboot is divided in 4 modules at the moment:

* vpc (generated by the _vpc-vpn-infra_ function): for vpc, subnets, NAT, vpn, ELK, monitoring and alerting boxes (the setup of the boxes is not automated at this point, see install-dns, install-icinga, install-influx, install-logstash)
* vpc dns (generated by the _vpc-public-dns_ function): for a number of public DNS names on the VPC (requires having a public domain on Route53).
* cluster (geenrated by _cluster-infra_ function): for individual clusters - the idea being that you can have several clusters per vpn.
* cluster dns (generated by _cluster-publlic-dns_ function): for cluster-specific DNS (also requires having a public domain on Route53)

There are two main configuration files: a edn files per module for fixed details, and more variable parameters (like instance types or open ports) in the calls to terraboot.

## edn files

This should contain details which are mostly fixed over the whole infrastructure. One of these file is passed in as an argument to `lein run`, for instance `lein run resources/terraboot-staging.edn`.

    {:region "your-aws-region"
     :bucket-name "your-s3-bucket"
     :aws-profile "your-aws-profile"
     :account-number "your-aws-account-number" ;; to generate ARN
     :azs [:a :b :c]
     :target "your-target"}



## Variable configuration

The more variable configuration goes in the clojure code.  By more variable I mean IP address ranges, names, open ports, instance types, disk sizes.
As this is likely to be a moving target, it's best to check the signature of the various functions to work out which parameters should be used.  The scenario we're going for now is a 'main' function calling the module functions with both a parameter EDN file and parameters

```
(ns my-setup.infra
  (:require [terraboot.core :refer :all]
            [terraboot.vpc :as vpc]
            [terraboot.public-dns :as dns]
            [terraboot.cluster :as cluster]
            [clojure.edn :as edn]
            [clojure.java.io :as io]))

(defn get-config
  "Gets info from a config file."
  [url]
  (edn/read-string (slurp url)))

(defn generate-json [edn-path]
  (let [{:keys [account-number
                region
                azs
                bucket-name
                aws-profile
                target]}) (get-config (edn-path)
        mesos-ami "" ;; desired CoreOS AMI
        default-ami "" ;; desired Ubuntu AMI
        vpc-cidr-block "" ;; VPC address range
        dns-zone "mastodonc.net" ;; if public dns is to be used
        dns-zone-id ""] ;; AWS zone id
        (condp = target
          "vpc" (do (to-file (vpc/vpc-vpn-infra {... parameters}) "vpc/vpc.tf")
                    (to-file (dns/vpc-public-dns {... parameters}) "vpc/vpc-dns.tf"))
          "dataplatform" (do (to-file (cluster/cluster-info {... parameters}) "dataplatform/dataplatform.tf")
                             (to-file (dns/cluster-public-dns {... parameters}) "dataplatform/dataplatform-dns.tf")))))

(defn -main [edn-path]
  (generate-json edn-path))
```

The *.tf files referred to in the code are the terraform json file terraform will consume. It's recommended to put them in their own directory, since terraform reads all tf file in a directory.

## Running it all

How to run a component: generate relevant configuration file

```
lein run resources/terraboot-vpc.edn # takes edn path
```
In relevant directory (where tf files live)
```
terraform plan .
```
If planning result looks like what you'd expect (green, number of resources to plan)
```
terraform apply .
```
